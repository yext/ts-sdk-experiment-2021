/* tslint:disable */
/* eslint-disable */
/**
 * Yext API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Asset,
    AssetFromJSON,
    AssetToJSON,
    AssetResponse,
    AssetResponseFromJSON,
    AssetResponseToJSON,
    AssetsResponse,
    AssetsResponseFromJSON,
    AssetsResponseToJSON,
    Bio,
    BioFromJSON,
    BioToJSON,
    BioListResponse,
    BioListResponseFromJSON,
    BioListResponseToJSON,
    BioListsResponse,
    BioListsResponseFromJSON,
    BioListsResponseToJSON,
    BusinessCategoriesResponse,
    BusinessCategoriesResponseFromJSON,
    BusinessCategoriesResponseToJSON,
    CustomFieldResponse,
    CustomFieldResponseFromJSON,
    CustomFieldResponseToJSON,
    CustomFieldsResponse,
    CustomFieldsResponseFromJSON,
    CustomFieldsResponseToJSON,
    EmptyResponse,
    EmptyResponseFromJSON,
    EmptyResponseToJSON,
    EntityWrite,
    EntityWriteFromJSON,
    EntityWriteToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    Event,
    EventFromJSON,
    EventToJSON,
    EventListResponse,
    EventListResponseFromJSON,
    EventListResponseToJSON,
    EventListsResponse,
    EventListsResponseFromJSON,
    EventListsResponseToJSON,
    Field,
    FieldFromJSON,
    FieldToJSON,
    FieldUpdate,
    FieldUpdateFromJSON,
    FieldUpdateToJSON,
    FoldersResponse,
    FoldersResponseFromJSON,
    FoldersResponseToJSON,
    GoogleFieldsResponse,
    GoogleFieldsResponseFromJSON,
    GoogleFieldsResponseToJSON,
    IdResponse,
    IdResponseFromJSON,
    IdResponseToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse2004,
    InlineResponse2004FromJSON,
    InlineResponse2004ToJSON,
    InlineResponse201,
    InlineResponse201FromJSON,
    InlineResponse201ToJSON,
    InlineResponse400,
    InlineResponse400FromJSON,
    InlineResponse400ToJSON,
    LanguageProfileResponse,
    LanguageProfileResponseFromJSON,
    LanguageProfileResponseToJSON,
    LanguageProfilesResponse,
    LanguageProfilesResponseFromJSON,
    LanguageProfilesResponseToJSON,
    Location,
    LocationFromJSON,
    LocationToJSON,
    LocationResponse,
    LocationResponseFromJSON,
    LocationResponseToJSON,
    LocationsResponse,
    LocationsResponseFromJSON,
    LocationsResponseToJSON,
    LocationsSearchResponse,
    LocationsSearchResponseFromJSON,
    LocationsSearchResponseToJSON,
    Menu,
    MenuFromJSON,
    MenuToJSON,
    MenuListResponse,
    MenuListResponseFromJSON,
    MenuListResponseToJSON,
    MenuListsResponse,
    MenuListsResponseFromJSON,
    MenuListsResponseToJSON,
    Product,
    ProductFromJSON,
    ProductToJSON,
    ProductListResponse,
    ProductListResponseFromJSON,
    ProductListResponseToJSON,
    ProductListsResponse,
    ProductListsResponseFromJSON,
    ProductListsResponseToJSON,
} from '../models';

export interface CreateAssetRequest {
    accountId: string;
    v: string;
    format: string;
    asset: Asset;
}

export interface CreateBioRequest {
    accountId: string;
    v: string;
    bio: Bio;
}

export interface CreateCustomFieldRequest {
    v: string;
    accountId: string;
    field: Field;
}

export interface CreateEventRequest {
    accountId: string;
    v: string;
    event: Event;
}

export interface CreateLocationRequest {
    accountId: string;
    v: string;
    location: Location;
}

export interface CreateMenuRequest {
    accountId: string;
    v: string;
    menu: Menu;
}

export interface CreateProductRequest {
    accountId: string;
    v: string;
    product: Product;
}

export interface DeleteAssetRequest {
    accountId: string;
    assetId: string;
    v: string;
}

export interface DeleteBioListRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface DeleteCustomFieldRequest {
    v: string;
    accountId: string;
    customFieldId: string;
}

export interface DeleteEventListRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface DeleteLanguageProfileRequest {
    accountId: string;
    locationId: string;
    languageCode: string;
    v: string;
}

export interface DeleteMenuListRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface DeleteProductListRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface GetAssetRequest {
    accountId: string;
    assetId: string;
    v: string;
    format: string;
}

export interface GetBioRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface GetBiosRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
}

export interface GetBusinessCategoriesRequest {
    v: string;
    language?: string;
    country?: string;
    entityType?: GetBusinessCategoriesEntityTypeEnum;
}

export interface GetCustomFieldRequest {
    v: string;
    accountId: string;
    customFieldId: string;
}

export interface GetCustomFieldsRequest {
    v: string;
    accountId: string;
    offset?: number;
    limit?: number;
    pageToken?: string;
}

export interface GetEventRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface GetEventsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
}

export interface GetGoogleKeywordsRequest {
    v: string;
    language?: string;
    clientCategoryId?: string;
    countryCode?: string;
}

export interface GetLanguageProfileRequest {
    accountId: string;
    locationId: string;
    languageCode: string;
    v: string;
    resolvePlaceholders?: boolean;
}

export interface GetLanguageProfilesRequest {
    accountId: string;
    locationId: string;
    v: string;
    resolvePlaceholders?: boolean;
}

export interface GetLocationRequest {
    accountId: string;
    locationId: string;
    v: string;
    resolvePlaceholders?: boolean;
}

export interface GetLocationFoldersRequest {
    accountId: string;
    v: string;
    offset?: number;
    limit?: number;
}

export interface GetLocationsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
    resolvePlaceholders?: boolean;
    pageToken?: string;
}

export interface GetMenuRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface GetMenusRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
}

export interface GetProductRequest {
    accountId: string;
    listId: string;
    v: string;
}

export interface GetProductsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
}

export interface KnowledgeApiServerCreateEntityRequest {
    accountId: string;
    entityType: string;
    v: string;
    entityWrite: EntityWrite;
    format?: string;
    stripUnsupportedFormats?: boolean;
    templateFields?: string;
    templateId?: string;
}

export interface KnowledgeApiServerDeleteEntityRequest {
    accountId: string;
    entityId: string;
    v: string;
}

export interface KnowledgeApiServerDeleteLanguageProfileRequest {
    accountId: string;
    entityId: string;
    languageCode: string;
    v: string;
}

export interface KnowledgeApiServerGetEntityRequest {
    accountId: string;
    entityId: string;
    v: string;
    fields?: string;
    format?: string;
    resolvePlaceholders?: boolean;
}

export interface KnowledgeApiServerGetLanguageProfileRequest {
    accountId: string;
    entityId: string;
    languageCode: string;
    v: string;
    fields?: string;
    format?: string;
    rendered?: boolean;
}

export interface KnowledgeApiServerListAllLanguageProfilesRequest {
    accountId: string;
    v: string;
    entityTypes?: string;
    fields?: string;
    filter?: string;
    format?: string;
    languageCodes?: string;
    limit?: number;
    offset?: number;
    pageToken?: string;
    rendered?: string;
    sortBy?: string;
}

export interface KnowledgeApiServerListEntitiesRequest {
    accountId: string;
    v: string;
    entityTypes?: string;
    fields?: string;
    filter?: string;
    format?: string;
    languages?: string;
    limit?: number;
    offset?: number;
    pageToken?: string;
    resolvePlaceholders?: boolean;
    sortBy?: string;
}

export interface KnowledgeApiServerListLanguageProfilesRequest {
    accountId: string;
    entityId: string;
    v: string;
    entityTypes?: string;
    fields?: string;
    format?: string;
    languageCodes?: string;
    rendered?: string;
}

export interface KnowledgeApiServerUpdateEntityRequest {
    accountId: string;
    entityId: string;
    v: string;
    entityWrite: EntityWrite;
    format?: string;
    stripUnsupportedFormats?: boolean;
    templateFields?: string;
    templateId?: string;
}

export interface KnowledgeApiServerUpsertLanguageProfileRequest {
    accountId: string;
    entityId: string;
    languageCode: string;
    v: string;
    entityWrite: EntityWrite;
}

export interface ListAssetsRequest {
    accountId: string;
    v: string;
    format: string;
    offset?: number;
    limit?: number;
    pageToken?: string;
}

export interface SearchLocationsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
    filters?: string;
}

export interface UpdateAssetRequest {
    accountId: string;
    assetId: string;
    v: string;
    format: string;
    asset: Asset;
}

export interface UpdateBioRequest {
    accountId: string;
    listId: string;
    v: string;
    bio: Bio;
}

export interface UpdateCustomFieldRequest {
    v: string;
    accountId: string;
    customFieldId: string;
    fieldUpdate: FieldUpdate;
}

export interface UpdateEventRequest {
    accountId: string;
    listId: string;
    v: string;
    event: Event;
}

export interface UpdateLocationRequest {
    accountId: string;
    locationId: string;
    v: string;
    location: Location;
}

export interface UpdateMenuRequest {
    accountId: string;
    listId: string;
    v: string;
    menu: Menu;
}

export interface UpdateProductRequest {
    accountId: string;
    listId: string;
    v: string;
    product: Product;
}

export interface UpsertLanguageProfileRequest {
    accountId: string;
    locationId: string;
    languageCode: string;
    v: string;
    location: Location;
    primary?: boolean;
}

/**
 * 
 */
export class KnowledgeManagerApi extends runtime.BaseAPI {

    /**
     * Creates a new asset in an account.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
     * Assets: Create
     */
    async createAssetRaw(requestParameters: CreateAssetRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createAsset.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createAsset.');
        }

        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling createAsset.');
        }

        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling createAsset.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/assets`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetToJSON(requestParameters.asset),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new asset in an account.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
     * Assets: Create
     */
    async createAsset(requestParameters: CreateAssetRequest): Promise<IdResponse> {
        const response = await this.createAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create new Bio List.
     * Bios: Create
     */
    async createBioRaw(requestParameters: CreateBioRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createBio.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createBio.');
        }

        if (requestParameters.bio === null || requestParameters.bio === undefined) {
            throw new runtime.RequiredError('bio','Required parameter requestParameters.bio was null or undefined when calling createBio.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/bios`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BioToJSON(requestParameters.bio),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Create new Bio List.
     * Bios: Create
     */
    async createBio(requestParameters: CreateBioRequest): Promise<IdResponse> {
        const response = await this.createBioRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new Custom Field in an Account. 
     * Custom Fields: Create
     */
    async createCustomFieldRaw(requestParameters: CreateCustomFieldRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createCustomField.');
        }

        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createCustomField.');
        }

        if (requestParameters.field === null || requestParameters.field === undefined) {
            throw new runtime.RequiredError('field','Required parameter requestParameters.field was null or undefined when calling createCustomField.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/customfields`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FieldToJSON(requestParameters.field),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new Custom Field in an Account. 
     * Custom Fields: Create
     */
    async createCustomField(requestParameters: CreateCustomFieldRequest): Promise<IdResponse> {
        const response = await this.createCustomFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new Event List.
     * Events (Legacy): Create
     */
    async createEventRaw(requestParameters: CreateEventRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createEvent.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createEvent.');
        }

        if (requestParameters.event === null || requestParameters.event === undefined) {
            throw new runtime.RequiredError('event','Required parameter requestParameters.event was null or undefined when calling createEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/events`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EventToJSON(requestParameters.event),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Event List.
     * Events (Legacy): Create
     */
    async createEvent(requestParameters: CreateEventRequest): Promise<IdResponse> {
        const response = await this.createEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new Location.   ## Required fields * **`locationName`** * **`address`** * **`city`** * **`state`** * **`zip`**   ## Optional fields that trigger warnings Submitting invalid values for certain optional fields will not trigger an error response. Instead, the success response will contain warning messages explaining why the invalid optional values were not stored in the system. The fields that generate warning messages are: <br><br> * **`logo`** * **`photos`** * **`twitterHandle`** * **`facebookPageUrl`** * **`languages`** 
     * Locations (Legacy): Create
     */
    async createLocationRaw(requestParameters: CreateLocationRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createLocation.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createLocation.');
        }

        if (requestParameters.location === null || requestParameters.location === undefined) {
            throw new runtime.RequiredError('location','Required parameter requestParameters.location was null or undefined when calling createLocation.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationToJSON(requestParameters.location),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Location.   ## Required fields * **`locationName`** * **`address`** * **`city`** * **`state`** * **`zip`**   ## Optional fields that trigger warnings Submitting invalid values for certain optional fields will not trigger an error response. Instead, the success response will contain warning messages explaining why the invalid optional values were not stored in the system. The fields that generate warning messages are: <br><br> * **`logo`** * **`photos`** * **`twitterHandle`** * **`facebookPageUrl`** * **`languages`** 
     * Locations (Legacy): Create
     */
    async createLocation(requestParameters: CreateLocationRequest): Promise<IdResponse> {
        const response = await this.createLocationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Menus: Create
     */
    async createMenuRaw(requestParameters: CreateMenuRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createMenu.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createMenu.');
        }

        if (requestParameters.menu === null || requestParameters.menu === undefined) {
            throw new runtime.RequiredError('menu','Required parameter requestParameters.menu was null or undefined when calling createMenu.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/menus`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MenuToJSON(requestParameters.menu),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Menus: Create
     */
    async createMenu(requestParameters: CreateMenuRequest): Promise<IdResponse> {
        const response = await this.createMenuRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new Product List.
     * Products: Create
     */
    async createProductRaw(requestParameters: CreateProductRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createProduct.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createProduct.');
        }

        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling createProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/products`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductToJSON(requestParameters.product),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Product List.
     * Products: Create
     */
    async createProduct(requestParameters: CreateProductRequest): Promise<IdResponse> {
        const response = await this.createProductRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a specific asset.
     * Assets: Delete
     */
    async deleteAssetRaw(requestParameters: DeleteAssetRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteAsset.');
        }

        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling deleteAsset.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteAsset.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/assets/{assetId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters.assetId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Delete a specific asset.
     * Assets: Delete
     */
    async deleteAsset(requestParameters: DeleteAssetRequest): Promise<EmptyResponse> {
        const response = await this.deleteAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an existing Bios List.
     * Bios: Delete
     */
    async deleteBioListRaw(requestParameters: DeleteBioListRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteBioList.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling deleteBioList.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteBioList.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/bios/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Delete an existing Bios List.
     * Bios: Delete
     */
    async deleteBioList(requestParameters: DeleteBioListRequest): Promise<EmptyResponse> {
        const response = await this.deleteBioListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes a Custom Field in an Account.  The Custom Field will be removed from all locations, and all content entered in the Custom Field will be deleted permanently. 
     * Custom Fields: Delete
     */
    async deleteCustomFieldRaw(requestParameters: DeleteCustomFieldRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteCustomField.');
        }

        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteCustomField.');
        }

        if (requestParameters.customFieldId === null || requestParameters.customFieldId === undefined) {
            throw new runtime.RequiredError('customFieldId','Required parameter requestParameters.customFieldId was null or undefined when calling deleteCustomField.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/customfields/{customFieldId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"customFieldId"}}`, encodeURIComponent(String(requestParameters.customFieldId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Deletes a Custom Field in an Account.  The Custom Field will be removed from all locations, and all content entered in the Custom Field will be deleted permanently. 
     * Custom Fields: Delete
     */
    async deleteCustomField(requestParameters: DeleteCustomFieldRequest): Promise<EmptyResponse> {
        const response = await this.deleteCustomFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an existing Event List.
     * Events (Legacy): Delete
     */
    async deleteEventListRaw(requestParameters: DeleteEventListRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteEventList.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling deleteEventList.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteEventList.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/events/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Delete an existing Event List.
     * Events (Legacy): Delete
     */
    async deleteEventList(requestParameters: DeleteEventListRequest): Promise<EmptyResponse> {
        const response = await this.deleteEventListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Remove a Language Profile from a location.
     * Language Profiles (Legacy): Delete
     */
    async deleteLanguageProfileRaw(requestParameters: DeleteLanguageProfileRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteLanguageProfile.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling deleteLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling deleteLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}/profiles/{language_code}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))).replace(`{${"language_code"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Remove a Language Profile from a location.
     * Language Profiles (Legacy): Delete
     */
    async deleteLanguageProfile(requestParameters: DeleteLanguageProfileRequest): Promise<EmptyResponse> {
        const response = await this.deleteLanguageProfileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an existing Menu.
     * Menus: Delete
     */
    async deleteMenuListRaw(requestParameters: DeleteMenuListRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteMenuList.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling deleteMenuList.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteMenuList.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/menus/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Delete an existing Menu.
     * Menus: Delete
     */
    async deleteMenuList(requestParameters: DeleteMenuListRequest): Promise<EmptyResponse> {
        const response = await this.deleteMenuListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an existing Products List.
     * Products: Delete
     */
    async deleteProductListRaw(requestParameters: DeleteProductListRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteProductList.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling deleteProductList.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteProductList.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/products/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Delete an existing Products List.
     * Products: Delete
     */
    async deleteProductList(requestParameters: DeleteProductListRequest): Promise<EmptyResponse> {
        const response = await this.deleteProductListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a specific asset.
     * Assets: Get
     */
    async getAssetRaw(requestParameters: GetAssetRequest): Promise<runtime.ApiResponse<AssetResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAsset.');
        }

        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling getAsset.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getAsset.');
        }

        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling getAsset.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/assets/{assetId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters.assetId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetResponseFromJSON(jsonValue));
    }

    /**
     * Get a specific asset.
     * Assets: Get
     */
    async getAsset(requestParameters: GetAssetRequest): Promise<AssetResponse> {
        const response = await this.getAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a specific Bios List.
     * Bios: Get
     */
    async getBioRaw(requestParameters: GetBioRequest): Promise<runtime.ApiResponse<BioListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getBio.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling getBio.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getBio.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/bios/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BioListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific Bios List.
     * Bios: Get
     */
    async getBio(requestParameters: GetBioRequest): Promise<BioListResponse> {
        const response = await this.getBioRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Bio Lists for an account.
     * Bios: List
     */
    async getBiosRaw(requestParameters: GetBiosRequest): Promise<runtime.ApiResponse<BioListsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getBios.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getBios.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/bios`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BioListsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Bio Lists for an account.
     * Bios: List
     */
    async getBios(requestParameters: GetBiosRequest): Promise<BioListsResponse> {
        const response = await this.getBiosRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get available Categories.  All Locations are required to have an associated Category to assist with organization and search. Yext provides a hierarchy of business categories for this purpose, exposed by this API. 
     * Categories: List
     */
    async getBusinessCategoriesRaw(requestParameters: GetBusinessCategoriesRequest): Promise<runtime.ApiResponse<BusinessCategoriesResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getBusinessCategories.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        if (requestParameters.country !== undefined) {
            queryParameters['country'] = requestParameters.country;
        }

        if (requestParameters.entityType !== undefined) {
            queryParameters['entityType'] = requestParameters.entityType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BusinessCategoriesResponseFromJSON(jsonValue));
    }

    /**
     * Get available Categories.  All Locations are required to have an associated Category to assist with organization and search. Yext provides a hierarchy of business categories for this purpose, exposed by this API. 
     * Categories: List
     */
    async getBusinessCategories(requestParameters: GetBusinessCategoriesRequest): Promise<BusinessCategoriesResponse> {
        const response = await this.getBusinessCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets a specific Custom Field in an Account.
     * Custom Fields: Get
     */
    async getCustomFieldRaw(requestParameters: GetCustomFieldRequest): Promise<runtime.ApiResponse<CustomFieldResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getCustomField.');
        }

        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getCustomField.');
        }

        if (requestParameters.customFieldId === null || requestParameters.customFieldId === undefined) {
            throw new runtime.RequiredError('customFieldId','Required parameter requestParameters.customFieldId was null or undefined when calling getCustomField.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/customfields/{customFieldId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"customFieldId"}}`, encodeURIComponent(String(requestParameters.customFieldId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFieldResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific Custom Field in an Account.
     * Custom Fields: Get
     */
    async getCustomField(requestParameters: GetCustomFieldRequest): Promise<CustomFieldResponse> {
        const response = await this.getCustomFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of Custom Fields in an Account.
     * Custom Fields: List
     */
    async getCustomFieldsRaw(requestParameters: GetCustomFieldsRequest): Promise<runtime.ApiResponse<CustomFieldsResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getCustomFields.');
        }

        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getCustomFields.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/customfields`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFieldsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Custom Fields in an Account.
     * Custom Fields: List
     */
    async getCustomFields(requestParameters: GetCustomFieldsRequest): Promise<CustomFieldsResponse> {
        const response = await this.getCustomFieldsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a specific Event List.
     * Events (Legacy): Get
     */
    async getEventRaw(requestParameters: GetEventRequest): Promise<runtime.ApiResponse<EventListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getEvent.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling getEvent.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/events/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EventListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific Event List.
     * Events (Legacy): Get
     */
    async getEvent(requestParameters: GetEventRequest): Promise<EventListResponse> {
        const response = await this.getEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Event Lists for an account.
     * Events (Legacy): List
     */
    async getEventsRaw(requestParameters: GetEventsRequest): Promise<runtime.ApiResponse<EventListsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getEvents.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getEvents.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/events`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EventListsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Event Lists for an account.
     * Events (Legacy): List
     */
    async getEvents(requestParameters: GetEventsRequest): Promise<EventListsResponse> {
        const response = await this.getEventsRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Use the Google Fields endpoint to retrieve a complete list of Google\'s location attributes for each business category. This list includes attributes that may not apply to all Locations in an account. The set of attributes available to a Location depends on its primary business category. You can view and edit the attributes of Locations in the **`googleAttributes`** Location field.  **NOTE:** Google Attributes are managed by Google and are subject to change without notice. To prevent errors, make sure your API implementation is not dependent on the presence of specific attributes. 
     * Google Fields: List
     */
    async getGoogleKeywordsRaw(requestParameters: GetGoogleKeywordsRequest): Promise<runtime.ApiResponse<GoogleFieldsResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getGoogleKeywords.');
        }

        const queryParameters: any = {};

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        if (requestParameters.clientCategoryId !== undefined) {
            queryParameters['clientCategoryId'] = requestParameters.clientCategoryId;
        }

        if (requestParameters.countryCode !== undefined) {
            queryParameters['countryCode'] = requestParameters.countryCode;
        }

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/googlefields`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GoogleFieldsResponseFromJSON(jsonValue));
    }

    /**
     *  Use the Google Fields endpoint to retrieve a complete list of Google\'s location attributes for each business category. This list includes attributes that may not apply to all Locations in an account. The set of attributes available to a Location depends on its primary business category. You can view and edit the attributes of Locations in the **`googleAttributes`** Location field.  **NOTE:** Google Attributes are managed by Google and are subject to change without notice. To prevent errors, make sure your API implementation is not dependent on the presence of specific attributes. 
     * Google Fields: List
     */
    async getGoogleKeywords(requestParameters: GetGoogleKeywordsRequest): Promise<GoogleFieldsResponse> {
        const response = await this.getGoogleKeywordsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the the requested Language Profile for a given Location.
     * Language Profiles (Legacy): Get
     */
    async getLanguageProfileRaw(requestParameters: GetLanguageProfileRequest): Promise<runtime.ApiResponse<LanguageProfileResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLanguageProfile.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling getLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling getLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}/profiles/{language_code}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))).replace(`{${"language_code"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LanguageProfileResponseFromJSON(jsonValue));
    }

    /**
     * Gets the the requested Language Profile for a given Location.
     * Language Profiles (Legacy): Get
     */
    async getLanguageProfile(requestParameters: GetLanguageProfileRequest): Promise<LanguageProfileResponse> {
        const response = await this.getLanguageProfileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get Language Profiles for a Location.
     * Language Profiles (Legacy): List
     */
    async getLanguageProfilesRaw(requestParameters: GetLanguageProfilesRequest): Promise<runtime.ApiResponse<LanguageProfilesResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLanguageProfiles.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling getLanguageProfiles.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLanguageProfiles.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}/profiles`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LanguageProfilesResponseFromJSON(jsonValue));
    }

    /**
     * Get Language Profiles for a Location.
     * Language Profiles (Legacy): List
     */
    async getLanguageProfiles(requestParameters: GetLanguageProfilesRequest): Promise<LanguageProfilesResponse> {
        const response = await this.getLanguageProfilesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets the primary profile for a single Location.
     * Locations (Legacy): Get
     */
    async getLocationRaw(requestParameters: GetLocationRequest): Promise<runtime.ApiResponse<LocationResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLocation.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling getLocation.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLocation.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationResponseFromJSON(jsonValue));
    }

    /**
     * Gets the primary profile for a single Location.
     * Locations (Legacy): Get
     */
    async getLocation(requestParameters: GetLocationRequest): Promise<LocationResponse> {
        const response = await this.getLocationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of Location Folders in an Account.
     * Folders: List
     */
    async getLocationFoldersRaw(requestParameters: GetLocationFoldersRequest): Promise<runtime.ApiResponse<FoldersResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLocationFolders.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLocationFolders.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/folders`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoldersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Location Folders in an Account.
     * Folders: List
     */
    async getLocationFolders(requestParameters: GetLocationFoldersRequest): Promise<FoldersResponse> {
        const response = await this.getLocationFoldersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get multiple Locations (primary profiles only).
     * Locations (Legacy): List
     */
    async getLocationsRaw(requestParameters: GetLocationsRequest): Promise<runtime.ApiResponse<LocationsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLocations.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLocations.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationsResponseFromJSON(jsonValue));
    }

    /**
     * Get multiple Locations (primary profiles only).
     * Locations (Legacy): List
     */
    async getLocations(requestParameters: GetLocationsRequest): Promise<LocationsResponse> {
        const response = await this.getLocationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a specific Menu.
     * Menus: Get
     */
    async getMenuRaw(requestParameters: GetMenuRequest): Promise<runtime.ApiResponse<MenuListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getMenu.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling getMenu.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getMenu.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/menus/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MenuListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific Menu.
     * Menus: Get
     */
    async getMenu(requestParameters: GetMenuRequest): Promise<MenuListResponse> {
        const response = await this.getMenuRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Menus for an account.
     * Menus: List
     */
    async getMenusRaw(requestParameters: GetMenusRequest): Promise<runtime.ApiResponse<MenuListsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getMenus.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getMenus.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/menus`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MenuListsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Menus for an account.
     * Menus: List
     */
    async getMenus(requestParameters: GetMenusRequest): Promise<MenuListsResponse> {
        const response = await this.getMenusRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a specific Product List.
     * Products: Get
     */
    async getProductRaw(requestParameters: GetProductRequest): Promise<runtime.ApiResponse<ProductListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getProduct.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling getProduct.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/products/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific Product List.
     * Products: Get
     */
    async getProduct(requestParameters: GetProductRequest): Promise<ProductListResponse> {
        const response = await this.getProductRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Product Lists for an account.
     * Products: List
     */
    async getProductsRaw(requestParameters: GetProductsRequest): Promise<runtime.ApiResponse<ProductListsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getProducts.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getProducts.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/products`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductListsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Product Lists for an account.
     * Products: List
     */
    async getProducts(requestParameters: GetProductsRequest): Promise<ProductListsResponse> {
        const response = await this.getProductsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new Entity  **NOTE:**   * If the **`v`** parameter is before `20181129`: the 201 response contains the created Entity\'s **`id`**   * If the **`v`** parameter is on or after `20181129`: the 201 response contains the created Entity in its entirety 
     * Entities: Create
     */
    async knowledgeApiServerCreateEntityRaw(requestParameters: KnowledgeApiServerCreateEntityRequest): Promise<runtime.ApiResponse<InlineResponse201>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerCreateEntity.');
        }

        if (requestParameters.entityType === null || requestParameters.entityType === undefined) {
            throw new runtime.RequiredError('entityType','Required parameter requestParameters.entityType was null or undefined when calling knowledgeApiServerCreateEntity.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerCreateEntity.');
        }

        if (requestParameters.entityWrite === null || requestParameters.entityWrite === undefined) {
            throw new runtime.RequiredError('entityWrite','Required parameter requestParameters.entityWrite was null or undefined when calling knowledgeApiServerCreateEntity.');
        }

        const queryParameters: any = {};

        if (requestParameters.entityType !== undefined) {
            queryParameters['entityType'] = requestParameters.entityType;
        }

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.stripUnsupportedFormats !== undefined) {
            queryParameters['stripUnsupportedFormats'] = requestParameters.stripUnsupportedFormats;
        }

        if (requestParameters.templateFields !== undefined) {
            queryParameters['templateFields'] = requestParameters.templateFields;
        }

        if (requestParameters.templateId !== undefined) {
            queryParameters['templateId'] = requestParameters.templateId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entities`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EntityWriteToJSON(requestParameters.entityWrite),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse201FromJSON(jsonValue));
    }

    /**
     * Create a new Entity  **NOTE:**   * If the **`v`** parameter is before `20181129`: the 201 response contains the created Entity\'s **`id`**   * If the **`v`** parameter is on or after `20181129`: the 201 response contains the created Entity in its entirety 
     * Entities: Create
     */
    async knowledgeApiServerCreateEntity(requestParameters: KnowledgeApiServerCreateEntityRequest): Promise<InlineResponse201> {
        const response = await this.knowledgeApiServerCreateEntityRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete the Entity with the given ID
     * Entities: Delete
     */
    async knowledgeApiServerDeleteEntityRaw(requestParameters: KnowledgeApiServerDeleteEntityRequest): Promise<runtime.ApiResponse<InlineResponse2001>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerDeleteEntity.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerDeleteEntity.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerDeleteEntity.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entities/{entityId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Delete the Entity with the given ID
     * Entities: Delete
     */
    async knowledgeApiServerDeleteEntity(requestParameters: KnowledgeApiServerDeleteEntityRequest): Promise<InlineResponse2001> {
        const response = await this.knowledgeApiServerDeleteEntityRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a language profile
     * Entity Language Profiles: Delete
     */
    async knowledgeApiServerDeleteLanguageProfileRaw(requestParameters: KnowledgeApiServerDeleteLanguageProfileRequest): Promise<runtime.ApiResponse<InlineResponse2004>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerDeleteLanguageProfile.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerDeleteLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling knowledgeApiServerDeleteLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerDeleteLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))).replace(`{${"languageCode"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2004FromJSON(jsonValue));
    }

    /**
     * Delete a language profile
     * Entity Language Profiles: Delete
     */
    async knowledgeApiServerDeleteLanguageProfile(requestParameters: KnowledgeApiServerDeleteLanguageProfileRequest): Promise<InlineResponse2004> {
        const response = await this.knowledgeApiServerDeleteLanguageProfileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve information for an Entity with a given ID
     * Entities: Get
     */
    async knowledgeApiServerGetEntityRaw(requestParameters: KnowledgeApiServerGetEntityRequest): Promise<runtime.ApiResponse<InlineResponse201>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerGetEntity.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerGetEntity.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerGetEntity.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entities/{entityId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse201FromJSON(jsonValue));
    }

    /**
     * Retrieve information for an Entity with a given ID
     * Entities: Get
     */
    async knowledgeApiServerGetEntity(requestParameters: KnowledgeApiServerGetEntityRequest): Promise<InlineResponse201> {
        const response = await this.knowledgeApiServerGetEntityRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Language Profile for an Entity  **NOTE**:  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: Get
     */
    async knowledgeApiServerGetLanguageProfileRaw(requestParameters: KnowledgeApiServerGetLanguageProfileRequest): Promise<runtime.ApiResponse<InlineResponse201>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerGetLanguageProfile.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerGetLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling knowledgeApiServerGetLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerGetLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.rendered !== undefined) {
            queryParameters['rendered'] = requestParameters.rendered;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))).replace(`{${"languageCode"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse201FromJSON(jsonValue));
    }

    /**
     * Retrieve a Language Profile for an Entity  **NOTE**:  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: Get
     */
    async knowledgeApiServerGetLanguageProfile(requestParameters: KnowledgeApiServerGetLanguageProfileRequest): Promise<InlineResponse201> {
        const response = await this.knowledgeApiServerGetLanguageProfileRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a list of Language Profiles for Entities within an account  **NOTE:**  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: List All
     */
    async knowledgeApiServerListAllLanguageProfilesRaw(requestParameters: KnowledgeApiServerListAllLanguageProfilesRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerListAllLanguageProfiles.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerListAllLanguageProfiles.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityTypes !== undefined) {
            queryParameters['entityTypes'] = requestParameters.entityTypes;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.languageCodes !== undefined) {
            queryParameters['languageCodes'] = requestParameters.languageCodes;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.rendered !== undefined) {
            queryParameters['rendered'] = requestParameters.rendered;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entityprofiles`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * Retrieve a list of Language Profiles for Entities within an account  **NOTE:**  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: List All
     */
    async knowledgeApiServerListAllLanguageProfiles(requestParameters: KnowledgeApiServerListAllLanguageProfilesRequest): Promise<InlineResponse2003> {
        const response = await this.knowledgeApiServerListAllLanguageProfilesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a list of Entities within an account
     * Entities: List
     */
    async knowledgeApiServerListEntitiesRaw(requestParameters: KnowledgeApiServerListEntitiesRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerListEntities.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerListEntities.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityTypes !== undefined) {
            queryParameters['entityTypes'] = requestParameters.entityTypes;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.languages !== undefined) {
            queryParameters['languages'] = requestParameters.languages;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.resolvePlaceholders !== undefined) {
            queryParameters['resolvePlaceholders'] = requestParameters.resolvePlaceholders;
        }

        if (requestParameters.sortBy !== undefined) {
            queryParameters['sortBy'] = requestParameters.sortBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entities`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Retrieve a list of Entities within an account
     * Entities: List
     */
    async knowledgeApiServerListEntities(requestParameters: KnowledgeApiServerListEntitiesRequest): Promise<InlineResponse200> {
        const response = await this.knowledgeApiServerListEntitiesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve Language Profiles for an Entity  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: List
     */
    async knowledgeApiServerListLanguageProfilesRaw(requestParameters: KnowledgeApiServerListLanguageProfilesRequest): Promise<runtime.ApiResponse<InlineResponse2002>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerListLanguageProfiles.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerListLanguageProfiles.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerListLanguageProfiles.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityTypes !== undefined) {
            queryParameters['entityTypes'] = requestParameters.entityTypes;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.languageCodes !== undefined) {
            queryParameters['languageCodes'] = requestParameters.languageCodes;
        }

        if (requestParameters.rendered !== undefined) {
            queryParameters['rendered'] = requestParameters.rendered;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entityprofiles/{entityId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * Retrieve Language Profiles for an Entity  * If the **`v`** parameter is before `20190103`: by default, returned alternate Language Profiles include **`googleAttributes`** and **`categoryIds`** fields * If the **`v`** parameter is `20190103` or later: by default, returned alternate Language Profiles do not include **`googleAttributes`** and **`categoryIds`** fields. However, these fields can still be retrieved if the **`rendered`** parameter in the request is set to `true`. 
     * Entity Language Profiles: List
     */
    async knowledgeApiServerListLanguageProfiles(requestParameters: KnowledgeApiServerListLanguageProfilesRequest): Promise<InlineResponse2002> {
        const response = await this.knowledgeApiServerListLanguageProfilesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update the Entity with the given ID
     * Entities: Update
     */
    async knowledgeApiServerUpdateEntityRaw(requestParameters: KnowledgeApiServerUpdateEntityRequest): Promise<runtime.ApiResponse<InlineResponse201>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerUpdateEntity.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerUpdateEntity.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerUpdateEntity.');
        }

        if (requestParameters.entityWrite === null || requestParameters.entityWrite === undefined) {
            throw new runtime.RequiredError('entityWrite','Required parameter requestParameters.entityWrite was null or undefined when calling knowledgeApiServerUpdateEntity.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.stripUnsupportedFormats !== undefined) {
            queryParameters['stripUnsupportedFormats'] = requestParameters.stripUnsupportedFormats;
        }

        if (requestParameters.templateFields !== undefined) {
            queryParameters['templateFields'] = requestParameters.templateFields;
        }

        if (requestParameters.templateId !== undefined) {
            queryParameters['templateId'] = requestParameters.templateId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entities/{entityId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EntityWriteToJSON(requestParameters.entityWrite),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse201FromJSON(jsonValue));
    }

    /**
     * Update the Entity with the given ID
     * Entities: Update
     */
    async knowledgeApiServerUpdateEntity(requestParameters: KnowledgeApiServerUpdateEntityRequest): Promise<InlineResponse201> {
        const response = await this.knowledgeApiServerUpdateEntityRaw(requestParameters);
        return await response.value();
    }

    /**
     * Add a language profile
     * Entity Language Profiles: Upsert
     */
    async knowledgeApiServerUpsertLanguageProfileRaw(requestParameters: KnowledgeApiServerUpsertLanguageProfileRequest): Promise<runtime.ApiResponse<InlineResponse201>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling knowledgeApiServerUpsertLanguageProfile.');
        }

        if (requestParameters.entityId === null || requestParameters.entityId === undefined) {
            throw new runtime.RequiredError('entityId','Required parameter requestParameters.entityId was null or undefined when calling knowledgeApiServerUpsertLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling knowledgeApiServerUpsertLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling knowledgeApiServerUpsertLanguageProfile.');
        }

        if (requestParameters.entityWrite === null || requestParameters.entityWrite === undefined) {
            throw new runtime.RequiredError('entityWrite','Required parameter requestParameters.entityWrite was null or undefined when calling knowledgeApiServerUpsertLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/entityprofiles/{entityId}/{languageCode}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"entityId"}}`, encodeURIComponent(String(requestParameters.entityId))).replace(`{${"languageCode"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EntityWriteToJSON(requestParameters.entityWrite),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse201FromJSON(jsonValue));
    }

    /**
     * Add a language profile
     * Entity Language Profiles: Upsert
     */
    async knowledgeApiServerUpsertLanguageProfile(requestParameters: KnowledgeApiServerUpsertLanguageProfileRequest): Promise<InlineResponse201> {
        const response = await this.knowledgeApiServerUpsertLanguageProfileRaw(requestParameters);
        return await response.value();
    }

    /**
     * List assets in an account.
     * Assets: List
     */
    async listAssetsRaw(requestParameters: ListAssetsRequest): Promise<runtime.ApiResponse<AssetsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listAssets.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listAssets.');
        }

        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling listAssets.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/assets`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsResponseFromJSON(jsonValue));
    }

    /**
     * List assets in an account.
     * Assets: List
     */
    async listAssets(requestParameters: ListAssetsRequest): Promise<AssetsResponse> {
        const response = await this.listAssetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get multiple Locations (primary profiles only) that match provided filters.
     * Locations (Legacy): Search
     */
    async searchLocationsRaw(requestParameters: SearchLocationsRequest): Promise<runtime.ApiResponse<LocationsSearchResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling searchLocations.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling searchLocations.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.filters !== undefined) {
            queryParameters['filters'] = requestParameters.filters;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locationsearch`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationsSearchResponseFromJSON(jsonValue));
    }

    /**
     * Get multiple Locations (primary profiles only) that match provided filters.
     * Locations (Legacy): Search
     */
    async searchLocations(requestParameters: SearchLocationsRequest): Promise<LocationsSearchResponse> {
        const response = await this.searchLocationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a specific asset.  **NOTE**: This endpoint is a true PUT. Fields that are not provided in an update will be cleared. The entire Asset object must be provided in the request, except for its **`id`**, which is given in the path.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
     * Assets: Update
     */
    async updateAssetRaw(requestParameters: UpdateAssetRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateAsset.');
        }

        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling updateAsset.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateAsset.');
        }

        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling updateAsset.');
        }

        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling updateAsset.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/assets/{assetId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"assetId"}}`, encodeURIComponent(String(requestParameters.assetId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AssetToJSON(requestParameters.asset),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Update a specific asset.  **NOTE**: This endpoint is a true PUT. Fields that are not provided in an update will be cleared. The entire Asset object must be provided in the request, except for its **`id`**, which is given in the path.  **NOTE:** * If the **`v`** parameter is on or before `20190624`: only the first folder the Asset is available for will be returned in the legacy **`folderId`** field. * If the **`v`** parameter is after `20190624`: the complete list of folders the Asset is available to will be returned in the new **`folderIds`** field. **`folderId`** will not be returned. 
     * Assets: Update
     */
    async updateAsset(requestParameters: UpdateAssetRequest): Promise<IdResponse> {
        const response = await this.updateAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing Bios List.
     * Bios: Update
     */
    async updateBioRaw(requestParameters: UpdateBioRequest): Promise<runtime.ApiResponse<BioListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateBio.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling updateBio.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateBio.');
        }

        if (requestParameters.bio === null || requestParameters.bio === undefined) {
            throw new runtime.RequiredError('bio','Required parameter requestParameters.bio was null or undefined when calling updateBio.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/bios/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BioToJSON(requestParameters.bio),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BioListResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing Bios List.
     * Bios: Update
     */
    async updateBio(requestParameters: UpdateBioRequest): Promise<BioListResponse> {
        const response = await this.updateBioRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates a single Custom Field in an Account.  Note that the only updatable values in an existing Custom Field are its name, group, description, alternate language behavior, as well as available options if its `type` is `SINGLE_OPTION` or `MULTI_OPTION`.  * If options are modified, every location with that option selected will have the new value.  * If options are deleted, all locations with that option will no longer have that option selected.  * If the deleted options are the only options selected for a location, the location will no longer have a value set for that Custom Field. 
     * Custom Fields: Update
     */
    async updateCustomFieldRaw(requestParameters: UpdateCustomFieldRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateCustomField.');
        }

        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateCustomField.');
        }

        if (requestParameters.customFieldId === null || requestParameters.customFieldId === undefined) {
            throw new runtime.RequiredError('customFieldId','Required parameter requestParameters.customFieldId was null or undefined when calling updateCustomField.');
        }

        if (requestParameters.fieldUpdate === null || requestParameters.fieldUpdate === undefined) {
            throw new runtime.RequiredError('fieldUpdate','Required parameter requestParameters.fieldUpdate was null or undefined when calling updateCustomField.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/customfields/{customFieldId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"customFieldId"}}`, encodeURIComponent(String(requestParameters.customFieldId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FieldUpdateToJSON(requestParameters.fieldUpdate),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Updates a single Custom Field in an Account.  Note that the only updatable values in an existing Custom Field are its name, group, description, alternate language behavior, as well as available options if its `type` is `SINGLE_OPTION` or `MULTI_OPTION`.  * If options are modified, every location with that option selected will have the new value.  * If options are deleted, all locations with that option will no longer have that option selected.  * If the deleted options are the only options selected for a location, the location will no longer have a value set for that Custom Field. 
     * Custom Fields: Update
     */
    async updateCustomField(requestParameters: UpdateCustomFieldRequest): Promise<IdResponse> {
        const response = await this.updateCustomFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing Event List.
     * Events (Legacy): Update
     */
    async updateEventRaw(requestParameters: UpdateEventRequest): Promise<runtime.ApiResponse<EventListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateEvent.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling updateEvent.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateEvent.');
        }

        if (requestParameters.event === null || requestParameters.event === undefined) {
            throw new runtime.RequiredError('event','Required parameter requestParameters.event was null or undefined when calling updateEvent.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/events/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EventToJSON(requestParameters.event),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EventListResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing Event List.
     * Events (Legacy): Update
     */
    async updateEvent(requestParameters: UpdateEventRequest): Promise<EventListResponse> {
        const response = await this.updateEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates the primary profile for a Location.  **NOTE:** Despite using the PUT method, Locations: Update only updates supplied fields. Omitted fields are not modified.  **NOTE:** The Location\'s primary profile language can be changed by calling this endpoint with a different, but unused, language code. 
     * Locations (Legacy): Update
     */
    async updateLocationRaw(requestParameters: UpdateLocationRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateLocation.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling updateLocation.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateLocation.');
        }

        if (requestParameters.location === null || requestParameters.location === undefined) {
            throw new runtime.RequiredError('location','Required parameter requestParameters.location was null or undefined when calling updateLocation.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: LocationToJSON(requestParameters.location),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Updates the primary profile for a Location.  **NOTE:** Despite using the PUT method, Locations: Update only updates supplied fields. Omitted fields are not modified.  **NOTE:** The Location\'s primary profile language can be changed by calling this endpoint with a different, but unused, language code. 
     * Locations (Legacy): Update
     */
    async updateLocation(requestParameters: UpdateLocationRequest): Promise<IdResponse> {
        const response = await this.updateLocationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing Menu.
     * Menus: Update
     */
    async updateMenuRaw(requestParameters: UpdateMenuRequest): Promise<runtime.ApiResponse<MenuListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateMenu.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling updateMenu.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateMenu.');
        }

        if (requestParameters.menu === null || requestParameters.menu === undefined) {
            throw new runtime.RequiredError('menu','Required parameter requestParameters.menu was null or undefined when calling updateMenu.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/menus/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MenuToJSON(requestParameters.menu),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MenuListResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing Menu.
     * Menus: Update
     */
    async updateMenu(requestParameters: UpdateMenuRequest): Promise<MenuListResponse> {
        const response = await this.updateMenuRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an existing Product List.
     * Products: Update
     */
    async updateProductRaw(requestParameters: UpdateProductRequest): Promise<runtime.ApiResponse<ProductListResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateProduct.');
        }

        if (requestParameters.listId === null || requestParameters.listId === undefined) {
            throw new runtime.RequiredError('listId','Required parameter requestParameters.listId was null or undefined when calling updateProduct.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateProduct.');
        }

        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling updateProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/kjson';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/products/{listId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"listId"}}`, encodeURIComponent(String(requestParameters.listId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductToJSON(requestParameters.product),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductListResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing Product List.
     * Products: Update
     */
    async updateProduct(requestParameters: UpdateProductRequest): Promise<ProductListResponse> {
        const response = await this.updateProductRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates and / or sets the fields for a Language Profile  **NOTE:** You can change a Language Profile’s language by supplying a different (but unused) language code. 
     * Language Profiles (Legacy): Upsert
     */
    async upsertLanguageProfileRaw(requestParameters: UpsertLanguageProfileRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling upsertLanguageProfile.');
        }

        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling upsertLanguageProfile.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling upsertLanguageProfile.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling upsertLanguageProfile.');
        }

        if (requestParameters.location === null || requestParameters.location === undefined) {
            throw new runtime.RequiredError('location','Required parameter requestParameters.location was null or undefined when calling upsertLanguageProfile.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.primary !== undefined) {
            queryParameters['primary'] = requestParameters.primary;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/locations/{locationId}/profiles/{language_code}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))).replace(`{${"language_code"}}`, encodeURIComponent(String(requestParameters.languageCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: LocationToJSON(requestParameters.location),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Creates and / or sets the fields for a Language Profile  **NOTE:** You can change a Language Profile’s language by supplying a different (but unused) language code. 
     * Language Profiles (Legacy): Upsert
     */
    async upsertLanguageProfile(requestParameters: UpsertLanguageProfileRequest): Promise<EmptyResponse> {
        const response = await this.upsertLanguageProfileRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetBusinessCategoriesEntityTypeEnum {
    Atm = 'atm',
    Event = 'event',
    HealthcareFacility = 'healthcareFacility',
    HealthcareProfessional = 'healthcareProfessional',
    Location = 'location',
    Restaurant = 'restaurant'
}
