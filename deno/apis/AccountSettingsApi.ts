/* tslint:disable */
/* eslint-disable */
/**
 * Yext API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.ts';
import {
    AccountResponse,
    AccountResponseFromJSON,
    AccountResponseToJSON,
    AccountsResponse,
    AccountsResponseFromJSON,
    AccountsResponseToJSON,
    ApprovalGroup,
    ApprovalGroupFromJSON,
    ApprovalGroupToJSON,
    ApprovalGroupResponse,
    ApprovalGroupResponseFromJSON,
    ApprovalGroupResponseToJSON,
    ApprovalGroupsResponse,
    ApprovalGroupsResponseFromJSON,
    ApprovalGroupsResponseToJSON,
    AssignLinkedAccountRequest,
    AssignLinkedAccountRequestFromJSON,
    AssignLinkedAccountRequestToJSON,
    AssignLinkedAccountResponse,
    AssignLinkedAccountResponseFromJSON,
    AssignLinkedAccountResponseToJSON,
    CreateApprovalGroupRequest,
    CreateApprovalGroupRequestFromJSON,
    CreateApprovalGroupRequestToJSON,
    CreateUserRequest,
    CreateUserRequestFromJSON,
    CreateUserRequestToJSON,
    EmptyResponse,
    EmptyResponseFromJSON,
    EmptyResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    IdResponse,
    IdResponseFromJSON,
    IdResponseToJSON,
    LinkedAccountResponse,
    LinkedAccountResponseFromJSON,
    LinkedAccountResponseToJSON,
    LinkedAccountsResponse,
    LinkedAccountsResponseFromJSON,
    LinkedAccountsResponseToJSON,
    RolesResponse,
    RolesResponseFromJSON,
    RolesResponseToJSON,
    UpdatePasswordRequest,
    UpdatePasswordRequestFromJSON,
    UpdatePasswordRequestToJSON,
    UpdateUserRequest,
    UpdateUserRequestFromJSON,
    UpdateUserRequestToJSON,
    UserResponse,
    UserResponseFromJSON,
    UserResponseToJSON,
    UsersResponse,
    UsersResponseFromJSON,
    UsersResponseToJSON,
} from '../models/index.ts';

export interface AssignLinkedAccountOperationRequest {
    accountId: string;
    linkedAccountId: string;
    v: string;
    assignLinkedAccountRequest: AssignLinkedAccountRequest;
}

export interface CreateApprovalGroupOperationRequest {
    accountId: string;
    v: string;
    createApprovalGroupRequest: CreateApprovalGroupRequest;
}

export interface CreateUserOperationRequest {
    accountId: string;
    v: string;
    createUserRequest: CreateUserRequest;
}

export interface DeleteApprovalGroupRequest {
    accountId: string;
    v: string;
    approvalGroupId: string;
}

export interface DeleteUserRequest {
    accountId: string;
    v: string;
    userId: string;
}

export interface GetAccountRequest {
    accountId: string;
    v: string;
}

export interface GetApprovalGroupRequest {
    accountId: string;
    v: string;
    approvalGroupId: string;
}

export interface GetApprovalGroupsRequest {
    accountId: string;
    v: string;
}

export interface GetLinkedAccountRequest {
    accountId: string;
    linkedAccountId: string;
    v: string;
}

export interface GetRolesRequest {
    accountId: string;
    v: string;
}

export interface GetUserRequest {
    accountId: string;
    v: string;
    userId: string;
}

export interface GetUsersRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
}

export interface ListAccountsRequest {
    v: string;
    name?: string;
    limit?: number;
    offset?: number;
}

export interface ListLinkedAccountsRequest {
    accountId: string;
    v: string;
    entityIds?: Array<string>;
    publisherIds?: Array<string>;
    statuses?: Array<ListLinkedAccountsStatusesEnum>;
    pageToken?: string;
    limit?: number;
    offset?: number;
}

export interface UpdateApprovalGroupRequest {
    accountId: string;
    v: string;
    approvalGroupId: string;
    approvalGroup: ApprovalGroup;
}

export interface UpdateUserOperationRequest {
    accountId: string;
    v: string;
    userId: string;
    updateUserRequest: UpdateUserRequest;
}

export interface UpdateUserPasswordRequest {
    accountId: string;
    v: string;
    userId: string;
    updatePasswordRequest?: UpdatePasswordRequest;
}

/**
 * 
 */
export class AccountSettingsApi extends runtime.BaseAPI {

    /**
     * Copy an eligible Linked Account from the top-level parent account to a subaccount. Optionally assign the Linked Account to an entity in the subaccount.  This functionality is only available for certain Yext accounts. Please reach out to your Yext representative for more information. 
     * LinkedAccounts: Assign
     */
    async assignLinkedAccountRaw(requestParameters: AssignLinkedAccountOperationRequest): Promise<runtime.ApiResponse<AssignLinkedAccountResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling assignLinkedAccount.');
        }

        if (requestParameters.linkedAccountId === null || requestParameters.linkedAccountId === undefined) {
            throw new runtime.RequiredError('linkedAccountId','Required parameter requestParameters.linkedAccountId was null or undefined when calling assignLinkedAccount.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling assignLinkedAccount.');
        }

        if (requestParameters.assignLinkedAccountRequest === null || requestParameters.assignLinkedAccountRequest === undefined) {
            throw new runtime.RequiredError('assignLinkedAccountRequest','Required parameter requestParameters.assignLinkedAccountRequest was null or undefined when calling assignLinkedAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/linkedaccounts/{linkedAccountId}/assign`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"linkedAccountId"}}`, encodeURIComponent(String(requestParameters.linkedAccountId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AssignLinkedAccountRequestToJSON(requestParameters.assignLinkedAccountRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssignLinkedAccountResponseFromJSON(jsonValue));
    }

    /**
     * Copy an eligible Linked Account from the top-level parent account to a subaccount. Optionally assign the Linked Account to an entity in the subaccount.  This functionality is only available for certain Yext accounts. Please reach out to your Yext representative for more information. 
     * LinkedAccounts: Assign
     */
    async assignLinkedAccount(requestParameters: AssignLinkedAccountOperationRequest): Promise<AssignLinkedAccountResponse> {
        const response = await this.assignLinkedAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates an Approval Group.
     * Approval Groups: Create
     */
    async createApprovalGroupRaw(requestParameters: CreateApprovalGroupOperationRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createApprovalGroup.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createApprovalGroup.');
        }

        if (requestParameters.createApprovalGroupRequest === null || requestParameters.createApprovalGroupRequest === undefined) {
            throw new runtime.RequiredError('createApprovalGroupRequest','Required parameter requestParameters.createApprovalGroupRequest was null or undefined when calling createApprovalGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/approvalgroups`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateApprovalGroupRequestToJSON(requestParameters.createApprovalGroupRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Creates an Approval Group.
     * Approval Groups: Create
     */
    async createApprovalGroup(requestParameters: CreateApprovalGroupOperationRequest): Promise<IdResponse> {
        const response = await this.createApprovalGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a new User  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be accepted in the request body.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be accepted in the request body. 
     * Users: Create
     */
    async createUserRaw(requestParameters: CreateUserOperationRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createUser.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createUser.');
        }

        if (requestParameters.createUserRequest === null || requestParameters.createUserRequest === undefined) {
            throw new runtime.RequiredError('createUserRequest','Required parameter requestParameters.createUserRequest was null or undefined when calling createUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateUserRequestToJSON(requestParameters.createUserRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Create a new User  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be accepted in the request body.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be accepted in the request body. 
     * Users: Create
     */
    async createUser(requestParameters: CreateUserOperationRequest): Promise<IdResponse> {
        const response = await this.createUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes an Approval Group.
     * ApprovalGroups: Delete
     */
    async deleteApprovalGroupRaw(requestParameters: DeleteApprovalGroupRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteApprovalGroup.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteApprovalGroup.');
        }

        if (requestParameters.approvalGroupId === null || requestParameters.approvalGroupId === undefined) {
            throw new runtime.RequiredError('approvalGroupId','Required parameter requestParameters.approvalGroupId was null or undefined when calling deleteApprovalGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/approvalgroups/{approvalGroupId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"approvalGroupId"}}`, encodeURIComponent(String(requestParameters.approvalGroupId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Deletes an Approval Group.
     * ApprovalGroups: Delete
     */
    async deleteApprovalGroup(requestParameters: DeleteApprovalGroupRequest): Promise<EmptyResponse> {
        const response = await this.deleteApprovalGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes an existing User.
     * Users: Delete
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteUser.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteUser.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users/{userId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Deletes an existing User.
     * Users: Delete
     */
    async deleteUser(requestParameters: DeleteUserRequest): Promise<EmptyResponse> {
        const response = await this.deleteUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get details for an account
     * Accounts: Get
     */
    async getAccountRaw(requestParameters: GetAccountRequest): Promise<runtime.ApiResponse<AccountResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccount.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountResponseFromJSON(jsonValue));
    }

    /**
     * Get details for an account
     * Accounts: Get
     */
    async getAccount(requestParameters: GetAccountRequest): Promise<AccountResponse> {
        const response = await this.getAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets a single Approval Group.
     * ApprovalGroups: Get
     */
    async getApprovalGroupRaw(requestParameters: GetApprovalGroupRequest): Promise<runtime.ApiResponse<ApprovalGroupResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getApprovalGroup.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getApprovalGroup.');
        }

        if (requestParameters.approvalGroupId === null || requestParameters.approvalGroupId === undefined) {
            throw new runtime.RequiredError('approvalGroupId','Required parameter requestParameters.approvalGroupId was null or undefined when calling getApprovalGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/approvalgroups/{approvalGroupId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"approvalGroupId"}}`, encodeURIComponent(String(requestParameters.approvalGroupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApprovalGroupResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single Approval Group.
     * ApprovalGroups: Get
     */
    async getApprovalGroup(requestParameters: GetApprovalGroupRequest): Promise<ApprovalGroupResponse> {
        const response = await this.getApprovalGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Lists all Approval Groups in the account.
     * ApprovalGroups: List
     */
    async getApprovalGroupsRaw(requestParameters: GetApprovalGroupsRequest): Promise<runtime.ApiResponse<ApprovalGroupsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getApprovalGroups.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getApprovalGroups.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/approvalgroups`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ApprovalGroupsResponseFromJSON(jsonValue));
    }

    /**
     * Lists all Approval Groups in the account.
     * ApprovalGroups: List
     */
    async getApprovalGroups(requestParameters: GetApprovalGroupsRequest): Promise<ApprovalGroupsResponse> {
        const response = await this.getApprovalGroupsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get details for an linked account.
     * LinkedAccounts: Get
     */
    async getLinkedAccountRaw(requestParameters: GetLinkedAccountRequest): Promise<runtime.ApiResponse<LinkedAccountResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getLinkedAccount.');
        }

        if (requestParameters.linkedAccountId === null || requestParameters.linkedAccountId === undefined) {
            throw new runtime.RequiredError('linkedAccountId','Required parameter requestParameters.linkedAccountId was null or undefined when calling getLinkedAccount.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getLinkedAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/linkedaccounts/{linkedAccountId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"linkedAccountId"}}`, encodeURIComponent(String(requestParameters.linkedAccountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkedAccountResponseFromJSON(jsonValue));
    }

    /**
     * Get details for an linked account.
     * LinkedAccounts: Get
     */
    async getLinkedAccount(requestParameters: GetLinkedAccountRequest): Promise<LinkedAccountResponse> {
        const response = await this.getLinkedAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves a list of the roles that users can have within a customer’s account.
     * Roles: Get
     */
    async getRolesRaw(requestParameters: GetRolesRequest): Promise<runtime.ApiResponse<RolesResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getRoles.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getRoles.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/roles`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RolesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of the roles that users can have within a customer’s account.
     * Roles: Get
     */
    async getRoles(requestParameters: GetRolesRequest): Promise<RolesResponse> {
        const response = await this.getRolesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieves details of a specific User.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be included in the response.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be included in the response. 
     * Users: Get
     */
    async getUserRaw(requestParameters: GetUserRequest): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getUser.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getUser.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users/{userId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves details of a specific User.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be included in the response.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be included in the response. 
     * Users: Get
     */
    async getUser(requestParameters: GetUserRequest): Promise<UserResponse> {
        const response = await this.getUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Lists all Users in an account.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be included in the response.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be included in the response.  This endpoint does not support the **`all`** macro. 
     * Users: List
     */
    async getUsersRaw(requestParameters: GetUsersRequest): Promise<runtime.ApiResponse<UsersResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getUsers.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
    }

    /**
     * Lists all Users in an account.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be included in the response.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be included in the response.  This endpoint does not support the **`all`** macro. 
     * Users: List
     */
    async getUsers(requestParameters: GetUsersRequest): Promise<UsersResponse> {
        const response = await this.getUsersRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all accounts that you have access to. Unless you are in Partner Portal mode, this will only be your own account.
     * Accounts: List
     */
    async listAccountsRaw(requestParameters: ListAccountsRequest): Promise<runtime.ApiResponse<AccountsResponse>> {
        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listAccounts.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountsResponseFromJSON(jsonValue));
    }

    /**
     * List all accounts that you have access to. Unless you are in Partner Portal mode, this will only be your own account.
     * Accounts: List
     */
    async listAccounts(requestParameters: ListAccountsRequest): Promise<AccountsResponse> {
        const response = await this.listAccountsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Lists all linked accounts in an account.
     * LinkedAccounts: List
     */
    async listLinkedAccountsRaw(requestParameters: ListLinkedAccountsRequest): Promise<runtime.ApiResponse<LinkedAccountsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listLinkedAccounts.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listLinkedAccounts.');
        }

        const queryParameters: any = {};

        if (requestParameters.entityIds) {
            queryParameters['entityIds'] = requestParameters.entityIds;
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds;
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/linkedaccounts`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkedAccountsResponseFromJSON(jsonValue));
    }

    /**
     * Lists all linked accounts in an account.
     * LinkedAccounts: List
     */
    async listLinkedAccounts(requestParameters: ListLinkedAccountsRequest): Promise<LinkedAccountsResponse> {
        const response = await this.listLinkedAccountsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates a single Approval Group.  **NOTE:** Despite using the PUT method, Approval Groups: Update only updates supplied fields. Omitted fields are not modified. However, the users list will be overwritten with what the user provides. 
     * ApprovalGroups: Update
     */
    async updateApprovalGroupRaw(requestParameters: UpdateApprovalGroupRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateApprovalGroup.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateApprovalGroup.');
        }

        if (requestParameters.approvalGroupId === null || requestParameters.approvalGroupId === undefined) {
            throw new runtime.RequiredError('approvalGroupId','Required parameter requestParameters.approvalGroupId was null or undefined when calling updateApprovalGroup.');
        }

        if (requestParameters.approvalGroup === null || requestParameters.approvalGroup === undefined) {
            throw new runtime.RequiredError('approvalGroup','Required parameter requestParameters.approvalGroup was null or undefined when calling updateApprovalGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/approvalgroups/{approvalGroupId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"approvalGroupId"}}`, encodeURIComponent(String(requestParameters.approvalGroupId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApprovalGroupToJSON(requestParameters.approvalGroup),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Updates a single Approval Group.  **NOTE:** Despite using the PUT method, Approval Groups: Update only updates supplied fields. Omitted fields are not modified. However, the users list will be overwritten with what the user provides. 
     * ApprovalGroups: Update
     */
    async updateApprovalGroup(requestParameters: UpdateApprovalGroupRequest): Promise<IdResponse> {
        const response = await this.updateApprovalGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates an existing User.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be accepted in the request body.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be accepted in the request body. If not provided, existing values will be cleared. 
     * Users: Update
     */
    async updateUserRaw(requestParameters: UpdateUserOperationRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateUser.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateUser.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateUser.');
        }

        if (requestParameters.updateUserRequest === null || requestParameters.updateUserRequest === undefined) {
            throw new runtime.RequiredError('updateUserRequest','Required parameter requestParameters.updateUserRequest was null or undefined when calling updateUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users/{userId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateUserRequestToJSON(requestParameters.updateUserRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Updates an existing User.  **NOTE**:  If the **`v`** parameter is before `20190225`: **`displayLanguagePreference`** and **`emailLanguagePreference`** will not be accepted in the request body.  If the **`v`** parameter is `20190225` or later: **`displayLanguagePreference`** and **`emailLanguagePreference`** will be accepted in the request body. If not provided, existing values will be cleared. 
     * Users: Update
     */
    async updateUser(requestParameters: UpdateUserOperationRequest): Promise<IdResponse> {
        const response = await this.updateUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates a User\'s password.
     * Users: Update Password
     */
    async updateUserPasswordRaw(requestParameters: UpdateUserPasswordRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateUserPassword.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateUserPassword.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateUserPassword.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/users/{userId}/password`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePasswordRequestToJSON(requestParameters.updatePasswordRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Updates a User\'s password.
     * Users: Update Password
     */
    async updateUserPassword(requestParameters: UpdateUserPasswordRequest): Promise<EmptyResponse> {
        const response = await this.updateUserPasswordRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ListLinkedAccountsStatusesEnum {
    Valid = 'VALID',
    Invalid = 'INVALID'
}
