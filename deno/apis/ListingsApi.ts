/* tslint:disable */
/* eslint-disable */
/**
 * Yext API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.ts';
import {
    AdminInvite,
    AdminInviteFromJSON,
    AdminInviteToJSON,
    AnswerRequest,
    AnswerRequestFromJSON,
    AnswerRequestToJSON,
    CompleteVerificationResponse,
    CompleteVerificationResponseFromJSON,
    CompleteVerificationResponseToJSON,
    CreateAnswerResponse,
    CreateAnswerResponseFromJSON,
    CreateAnswerResponseToJSON,
    DuplicatesResponse,
    DuplicatesResponseFromJSON,
    DuplicatesResponseToJSON,
    EmptyResponse,
    EmptyResponseFromJSON,
    EmptyResponseToJSON,
    EntityListingsResponse,
    EntityListingsResponseFromJSON,
    EntityListingsResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    IdResponse,
    IdResponseFromJSON,
    IdResponseToJSON,
    InitiateVerificationResponse,
    InitiateVerificationResponseFromJSON,
    InitiateVerificationResponseToJSON,
    InviteAdminsResponse,
    InviteAdminsResponseFromJSON,
    InviteAdminsResponseToJSON,
    ListAdminsResponse,
    ListAdminsResponseFromJSON,
    ListAdminsResponseToJSON,
    ListMethodsResponse,
    ListMethodsResponseFromJSON,
    ListMethodsResponseToJSON,
    ListQuestionsReponse,
    ListQuestionsReponseFromJSON,
    ListQuestionsReponseToJSON,
    ListStatusesResponse,
    ListStatusesResponseFromJSON,
    ListStatusesResponseToJSON,
    ListingsResponse,
    ListingsResponseFromJSON,
    ListingsResponseToJSON,
    PublisherSuggestionResponse,
    PublisherSuggestionResponseFromJSON,
    PublisherSuggestionResponseToJSON,
    PublisherSuggestionsResponse,
    PublisherSuggestionsResponseFromJSON,
    PublisherSuggestionsResponseToJSON,
    PublishersResponse,
    PublishersResponseFromJSON,
    PublishersResponseToJSON,
    QuestionResponse,
    QuestionResponseFromJSON,
    QuestionResponseToJSON,
    UpdateAnswerResponse,
    UpdateAnswerResponseFromJSON,
    UpdateAnswerResponseToJSON,
    VerificationCompletion,
    VerificationCompletionFromJSON,
    VerificationCompletionToJSON,
    VerificationInitiation,
    VerificationInitiationFromJSON,
    VerificationInitiationToJSON,
} from '../models/index.ts';

export interface CompleteVerificationRequest {
    accountId: string;
    v: string;
    publisherId: string;
    verificationCompletion: Array<VerificationCompletion>;
}

export interface CreateAnswerRequest {
    accountId: string;
    questionId: number;
    v: string;
    answerRequest?: AnswerRequest;
}

export interface CreateDuplicateRequest {
    accountId: string;
    v: string;
    publisherId: string;
    url: string;
    locationId?: string;
}

export interface DeleteAnswerRequest {
    accountId: string;
    questionId: number;
    answerId: number;
    v: string;
}

export interface DeleteDuplicateRequest {
    accountId: string;
    v: string;
    duplicateId: string;
}

export interface DeleteListingsRequest {
    accountId: string;
    v: string;
    entityIds?: Array<string>;
    publisherIds?: Array<string>;
}

export interface GetPublisherSuggestionRequest {
    accountId: string;
    v: string;
    suggestionId: string;
}

export interface GetQuestionRequest {
    accountId: string;
    questionId: number;
    v: string;
}

export interface InitiateVerificationRequest {
    accountId: string;
    v: string;
    publisherId: string;
    locale: string;
    verificationInitiation: Array<VerificationInitiation>;
}

export interface InviteAdminsRequest {
    accountId: string;
    v: string;
    publisherId: string;
    adminInvite: Array<AdminInvite>;
}

export interface ListAdminsRequest {
    accountId: string;
    v: string;
    publisherId: string;
    entityIds?: string;
    pageToken?: string;
    limit?: number;
    offset?: number;
}

export interface ListDuplicatesRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
    locationIds?: Array<string>;
    publisherIds?: Array<string>;
    statuses?: Array<ListDuplicatesStatusesEnum>;
}

export interface ListEntityListingsRequest {
    accountId: string;
    v: string;
    entityIds?: Array<string>;
    publisherIds?: Array<string>;
    statuses?: Array<ListEntityListingsStatusesEnum>;
    language?: string;
    pageToken?: string;
    limit?: number;
    offset?: number;
}

export interface ListListingsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
    locationIds?: Array<string>;
    publisherIds?: Array<string>;
    statuses?: Array<ListListingsStatusesEnum>;
    language?: string;
}

export interface ListMethodsRequest {
    accountId: string;
    v: string;
    publisherId: string;
    locale: string;
    entityIds?: string;
    pageToken?: string;
    limit?: number;
    offset?: number;
}

export interface ListPublisherSuggestionsRequest {
    accountId: string;
    v: string;
    limit?: number;
    offset?: number;
    locationIds?: Array<string>;
    publisherIds?: Array<string>;
    statuses?: Array<ListPublisherSuggestionsStatusesEnum>;
}

export interface ListPublishersRequest {
    accountId: string;
    v: string;
    subset?: string;
    entityType?: Array<ListPublishersEntityTypeEnum>;
}

export interface ListQuestionsRequest {
    accountId: string;
    v: string;
    filter?: string;
    limit?: number;
    offset?: number;
    pageToken?: string;
}

export interface ListStatusesRequest {
    accountId: string;
    v: string;
    publisherId: string;
    entityIds?: string;
    pageToken?: string;
    limit?: number;
    offset?: number;
}

export interface OptInListingsRequest {
    accountId: string;
    v: string;
    locationIds?: Array<string>;
    publisherIds?: Array<string>;
}

export interface OptOutListingsRequest {
    accountId: string;
    v: string;
    locationIds?: Array<string>;
    publisherIds?: Array<string>;
}

export interface SuppressDuplicateRequest {
    accountId: string;
    v: string;
    duplicateId: string;
}

export interface UpdateAnswerRequest {
    accountId: string;
    questionId: number;
    answerId: number;
    v: string;
    answerRequest?: AnswerRequest;
}

export interface UpdatePublisherSuggestionRequest {
    accountId: string;
    v: string;
    suggestionId: string;
    status: UpdatePublisherSuggestionStatusEnum;
}

/**
 * 
 */
export class ListingsApi extends runtime.BaseAPI {

    /**
     * Provides verification codes to complete the verification for entities in an account. 
     * Verification: Complete
     */
    async completeVerificationRaw(requestParameters: CompleteVerificationRequest): Promise<runtime.ApiResponse<CompleteVerificationResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling completeVerification.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling completeVerification.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling completeVerification.');
        }

        if (requestParameters.verificationCompletion === null || requestParameters.verificationCompletion === undefined) {
            throw new runtime.RequiredError('verificationCompletion','Required parameter requestParameters.verificationCompletion was null or undefined when calling completeVerification.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/verifications/{publisherId}/complete`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.verificationCompletion.map(VerificationCompletionToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CompleteVerificationResponseFromJSON(jsonValue));
    }

    /**
     * Provides verification codes to complete the verification for entities in an account. 
     * Verification: Complete
     */
    async completeVerification(requestParameters: CompleteVerificationRequest): Promise<CompleteVerificationResponse> {
        const response = await this.completeVerificationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new Answer on a Question.
     * Answer: Create
     */
    async createAnswerRaw(requestParameters: CreateAnswerRequest): Promise<runtime.ApiResponse<CreateAnswerResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createAnswer.');
        }

        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling createAnswer.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createAnswer.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/questions/{questionId}/answers`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnswerRequestToJSON(requestParameters.answerRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateAnswerResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new Answer on a Question.
     * Answer: Create
     */
    async createAnswer(requestParameters: CreateAnswerRequest): Promise<CreateAnswerResponse> {
        const response = await this.createAnswerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a new Duplicate with **`status`** `SUPPRESSION_REQUESTED`.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Create
     */
    async createDuplicateRaw(requestParameters: CreateDuplicateRequest): Promise<runtime.ApiResponse<IdResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling createDuplicate.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling createDuplicate.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling createDuplicate.');
        }

        if (requestParameters.url === null || requestParameters.url === undefined) {
            throw new runtime.RequiredError('url','Required parameter requestParameters.url was null or undefined when calling createDuplicate.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.locationId !== undefined) {
            queryParameters['locationId'] = requestParameters.locationId;
        }

        if (requestParameters.publisherId !== undefined) {
            queryParameters['publisherId'] = requestParameters.publisherId;
        }

        if (requestParameters.url !== undefined) {
            queryParameters['url'] = requestParameters.url;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/duplicates`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IdResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new Duplicate with **`status`** `SUPPRESSION_REQUESTED`.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Create
     */
    async createDuplicate(requestParameters: CreateDuplicateRequest): Promise<IdResponse> {
        const response = await this.createDuplicateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes an Answer for a Question
     * Answer: Delete
     */
    async deleteAnswerRaw(requestParameters: DeleteAnswerRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteAnswer.');
        }

        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling deleteAnswer.');
        }

        if (requestParameters.answerId === null || requestParameters.answerId === undefined) {
            throw new runtime.RequiredError('answerId','Required parameter requestParameters.answerId was null or undefined when calling deleteAnswer.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteAnswer.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/questions/{questionId}/answers/{answerId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))).replace(`{${"answerId"}}`, encodeURIComponent(String(requestParameters.answerId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Deletes an Answer for a Question
     * Answer: Delete
     */
    async deleteAnswer(requestParameters: DeleteAnswerRequest): Promise<EmptyResponse> {
        const response = await this.deleteAnswerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Indicates that a Duplicate should be ignored.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Delete
     */
    async deleteDuplicateRaw(requestParameters: DeleteDuplicateRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteDuplicate.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteDuplicate.');
        }

        if (requestParameters.duplicateId === null || requestParameters.duplicateId === undefined) {
            throw new runtime.RequiredError('duplicateId','Required parameter requestParameters.duplicateId was null or undefined when calling deleteDuplicate.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/duplicates/{duplicateId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"duplicateId"}}`, encodeURIComponent(String(requestParameters.duplicateId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Indicates that a Duplicate should be ignored.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Delete
     */
    async deleteDuplicate(requestParameters: DeleteDuplicateRequest): Promise<EmptyResponse> {
        const response = await this.deleteDuplicateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deletes event listings from publishers. If deletion is not supported by the publisher, then service is removed instead.  **NOTE:** You can delete a maximum of 100 listings in a single request. If the number of Entity IDs multiplied by the number of Publisher IDs in your request exceeds 100, you will receive a 400 error response.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Entity Listings: Delete
     */
    async deleteListingsRaw(requestParameters: DeleteListingsRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling deleteListings.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling deleteListings.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityIds) {
            queryParameters['entityIds'] = requestParameters.entityIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/delete`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Deletes event listings from publishers. If deletion is not supported by the publisher, then service is removed instead.  **NOTE:** You can delete a maximum of 100 listings in a single request. If the number of Entity IDs multiplied by the number of Publisher IDs in your request exceeds 100, you will receive a 400 error response.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Entity Listings: Delete
     */
    async deleteListings(requestParameters: DeleteListingsRequest): Promise<EmptyResponse> {
        const response = await this.deleteListingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetches details of a specific Publisher Suggestion
     * Publisher Suggestions: Get
     */
    async getPublisherSuggestionRaw(requestParameters: GetPublisherSuggestionRequest): Promise<runtime.ApiResponse<PublisherSuggestionResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getPublisherSuggestion.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getPublisherSuggestion.');
        }

        if (requestParameters.suggestionId === null || requestParameters.suggestionId === undefined) {
            throw new runtime.RequiredError('suggestionId','Required parameter requestParameters.suggestionId was null or undefined when calling getPublisherSuggestion.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/publishersuggestions/{suggestionId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"suggestionId"}}`, encodeURIComponent(String(requestParameters.suggestionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PublisherSuggestionResponseFromJSON(jsonValue));
    }

    /**
     * Fetches details of a specific Publisher Suggestion
     * Publisher Suggestions: Get
     */
    async getPublisherSuggestion(requestParameters: GetPublisherSuggestionRequest): Promise<PublisherSuggestionResponse> {
        const response = await this.getPublisherSuggestionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve information for a Question
     * Question: Get
     */
    async getQuestionRaw(requestParameters: GetQuestionRequest): Promise<runtime.ApiResponse<QuestionResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getQuestion.');
        }

        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling getQuestion.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling getQuestion.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/questions/{questionId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve information for a Question
     * Question: Get
     */
    async getQuestion(requestParameters: GetQuestionRequest): Promise<QuestionResponse> {
        const response = await this.getQuestionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Initiate verification for entities in an account. This request will trigger verification codes being sent to the specified addresses, phone numbers, or email addresses. 
     * Verification: Initiate
     */
    async initiateVerificationRaw(requestParameters: InitiateVerificationRequest): Promise<runtime.ApiResponse<InitiateVerificationResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling initiateVerification.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling initiateVerification.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling initiateVerification.');
        }

        if (requestParameters.locale === null || requestParameters.locale === undefined) {
            throw new runtime.RequiredError('locale','Required parameter requestParameters.locale was null or undefined when calling initiateVerification.');
        }

        if (requestParameters.verificationInitiation === null || requestParameters.verificationInitiation === undefined) {
            throw new runtime.RequiredError('verificationInitiation','Required parameter requestParameters.verificationInitiation was null or undefined when calling initiateVerification.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/verifications/{publisherId}/{locale}/initiate`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))).replace(`{${"locale"}}`, encodeURIComponent(String(requestParameters.locale))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.verificationInitiation.map(VerificationInitiationToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InitiateVerificationResponseFromJSON(jsonValue));
    }

    /**
     * Initiate verification for entities in an account. This request will trigger verification codes being sent to the specified addresses, phone numbers, or email addresses. 
     * Verification: Initiate
     */
    async initiateVerification(requestParameters: InitiateVerificationRequest): Promise<InitiateVerificationResponse> {
        const response = await this.initiateVerificationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Sends invitations to new listing admins for entities in an account. For Google My Business listings, the admins will be given owner-level access. 
     * Listing Admin: Invite
     */
    async inviteAdminsRaw(requestParameters: InviteAdminsRequest): Promise<runtime.ApiResponse<InviteAdminsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling inviteAdmins.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling inviteAdmins.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling inviteAdmins.');
        }

        if (requestParameters.adminInvite === null || requestParameters.adminInvite === undefined) {
            throw new runtime.RequiredError('adminInvite','Required parameter requestParameters.adminInvite was null or undefined when calling inviteAdmins.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/admins/{publisherId}/invite`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.adminInvite.map(AdminInviteToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteAdminsResponseFromJSON(jsonValue));
    }

    /**
     * Sends invitations to new listing admins for entities in an account. For Google My Business listings, the admins will be given owner-level access. 
     * Listing Admin: Invite
     */
    async inviteAdmins(requestParameters: InviteAdminsRequest): Promise<InviteAdminsResponse> {
        const response = await this.inviteAdminsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve listing admins for entities in an account. 
     * Listing Admins: List
     */
    async listAdminsRaw(requestParameters: ListAdminsRequest): Promise<runtime.ApiResponse<ListAdminsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listAdmins.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listAdmins.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling listAdmins.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityIds !== undefined) {
            queryParameters['entityIds'] = requestParameters.entityIds;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/admins/{publisherId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAdminsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve listing admins for entities in an account. 
     * Listing Admins: List
     */
    async listAdmins(requestParameters: ListAdminsRequest): Promise<ListAdminsResponse> {
        const response = await this.listAdminsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve Duplicates for an account  If the **`v`** parameter is `20180802` or later: only duplicates of live listings (**`status`**: `LIVE`) will be included 
     * Duplicates: List
     */
    async listDuplicatesRaw(requestParameters: ListDuplicatesRequest): Promise<runtime.ApiResponse<DuplicatesResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listDuplicates.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listDuplicates.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.locationIds) {
            queryParameters['locationIds'] = requestParameters.locationIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/duplicates`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DuplicatesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve Duplicates for an account  If the **`v`** parameter is `20180802` or later: only duplicates of live listings (**`status`**: `LIVE`) will be included 
     * Duplicates: List
     */
    async listDuplicates(requestParameters: ListDuplicatesRequest): Promise<DuplicatesResponse> {
        const response = await this.listDuplicatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Entity Listings matching the given criteria. Includes the status of each Listing and reasons why a Listing may not be live. This endpoint currently only supports Event Listings.  The results will first be sorted by publisher and then by Entity.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Entity Listings: List
     */
    async listEntityListingsRaw(requestParameters: ListEntityListingsRequest): Promise<runtime.ApiResponse<EntityListingsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listEntityListings.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listEntityListings.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityIds) {
            queryParameters['entityIds'] = requestParameters.entityIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/entitylistings`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityListingsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Entity Listings matching the given criteria. Includes the status of each Listing and reasons why a Listing may not be live. This endpoint currently only supports Event Listings.  The results will first be sorted by publisher and then by Entity.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Entity Listings: List
     */
    async listEntityListings(requestParameters: ListEntityListingsRequest): Promise<EntityListingsResponse> {
        const response = await this.listEntityListingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Listings matching the given criteria including status and reasons why a Listing may be unavailable  The results will first be sorted by publisher and then by Location.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Listings: List
     */
    async listListingsRaw(requestParameters: ListListingsRequest): Promise<runtime.ApiResponse<ListingsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listListings.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listListings.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.locationIds) {
            queryParameters['locationIds'] = requestParameters.locationIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/listings`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListingsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all Listings matching the given criteria including status and reasons why a Listing may be unavailable  The results will first be sorted by publisher and then by Location.  **Support for `all` macro:** If you would like to use this endpoint to take action on your account and all of its sub-accounts, you can use the `all` macro in place of your account ID in your request URLs. For more information, see the \"Account ID\" section of \"Policies and Conventions\" at the top of this page. 
     * Listings: List
     */
    async listListings(requestParameters: ListListingsRequest): Promise<ListingsResponse> {
        const response = await this.listListingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve verification methods for entities in an account 
     * Verification Methods: List
     */
    async listMethodsRaw(requestParameters: ListMethodsRequest): Promise<runtime.ApiResponse<ListMethodsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listMethods.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listMethods.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling listMethods.');
        }

        if (requestParameters.locale === null || requestParameters.locale === undefined) {
            throw new runtime.RequiredError('locale','Required parameter requestParameters.locale was null or undefined when calling listMethods.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityIds !== undefined) {
            queryParameters['entityIds'] = requestParameters.entityIds;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/verifications/{publisherId}/{locale}/methods`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))).replace(`{${"locale"}}`, encodeURIComponent(String(requestParameters.locale))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListMethodsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve verification methods for entities in an account 
     * Verification Methods: List
     */
    async listMethods(requestParameters: ListMethodsRequest): Promise<ListMethodsResponse> {
        const response = await this.listMethodsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve suggestions publishers have submitted for the Locations in an account
     * Publisher Suggestions: List
     */
    async listPublisherSuggestionsRaw(requestParameters: ListPublisherSuggestionsRequest): Promise<runtime.ApiResponse<PublisherSuggestionsResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listPublisherSuggestions.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listPublisherSuggestions.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.locationIds) {
            queryParameters['locationIds'] = requestParameters.locationIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statuses) {
            queryParameters['statuses'] = requestParameters.statuses.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/publishersuggestions`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PublisherSuggestionsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve suggestions publishers have submitted for the Locations in an account
     * Publisher Suggestions: List
     */
    async listPublisherSuggestions(requestParameters: ListPublisherSuggestionsRequest): Promise<PublisherSuggestionsResponse> {
        const response = await this.listPublisherSuggestionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a list of publishers included in an account\'s subscription 
     * Publishers: List
     */
    async listPublishersRaw(requestParameters: ListPublishersRequest): Promise<runtime.ApiResponse<PublishersResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listPublishers.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listPublishers.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.subset !== undefined) {
            queryParameters['subset'] = requestParameters.subset;
        }

        if (requestParameters.entityType) {
            queryParameters['entityType'] = requestParameters.entityType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/publishers`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PublishersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of publishers included in an account\'s subscription 
     * Publishers: List
     */
    async listPublishers(requestParameters: ListPublishersRequest): Promise<PublishersResponse> {
        const response = await this.listPublishersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a list of Questions within an account.
     * Questions: List 
     */
    async listQuestionsRaw(requestParameters: ListQuestionsRequest): Promise<runtime.ApiResponse<ListQuestionsReponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listQuestions.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listQuestions.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/questions`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListQuestionsReponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of Questions within an account.
     * Questions: List 
     */
    async listQuestions(requestParameters: ListQuestionsRequest): Promise<ListQuestionsReponse> {
        const response = await this.listQuestionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve verification statuses for entities in an account 
     * Verification Statuses: List
     */
    async listStatusesRaw(requestParameters: ListStatusesRequest): Promise<runtime.ApiResponse<ListStatusesResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling listStatuses.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling listStatuses.');
        }

        if (requestParameters.publisherId === null || requestParameters.publisherId === undefined) {
            throw new runtime.RequiredError('publisherId','Required parameter requestParameters.publisherId was null or undefined when calling listStatuses.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.entityIds !== undefined) {
            queryParameters['entityIds'] = requestParameters.entityIds;
        }

        if (requestParameters.pageToken !== undefined) {
            queryParameters['pageToken'] = requestParameters.pageToken;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/verifications/{publisherId}/statuses`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"publisherId"}}`, encodeURIComponent(String(requestParameters.publisherId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ListStatusesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve verification statuses for entities in an account 
     * Verification Statuses: List
     */
    async listStatuses(requestParameters: ListStatusesRequest): Promise<ListStatusesResponse> {
        const response = await this.listStatusesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Opts designated locations into designated publishers  **NOTE:** The number of Location IDs multiplied by the number of Publisher IDs is capped at 100. If you exceed this, you will receive a 400 error response. 
     * Listings: Opt In
     */
    async optInListingsRaw(requestParameters: OptInListingsRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling optInListings.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling optInListings.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.locationIds) {
            queryParameters['locationIds'] = requestParameters.locationIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/listings/optin`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Opts designated locations into designated publishers  **NOTE:** The number of Location IDs multiplied by the number of Publisher IDs is capped at 100. If you exceed this, you will receive a 400 error response. 
     * Listings: Opt In
     */
    async optInListings(requestParameters: OptInListingsRequest): Promise<EmptyResponse> {
        const response = await this.optInListingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Opts designated locations out of designated publishers  **NOTE:** The number of Location IDs multiplied by the number of Publisher IDs is capped at 100. If you exceed this, you will receive a 400 error response. 
     * Listings: Opt Out
     */
    async optOutListingsRaw(requestParameters: OptOutListingsRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling optOutListings.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling optOutListings.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.locationIds) {
            queryParameters['locationIds'] = requestParameters.locationIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.publisherIds) {
            queryParameters['publisherIds'] = requestParameters.publisherIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/listings/optout`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Opts designated locations out of designated publishers  **NOTE:** The number of Location IDs multiplied by the number of Publisher IDs is capped at 100. If you exceed this, you will receive a 400 error response. 
     * Listings: Opt Out
     */
    async optOutListings(requestParameters: OptOutListingsRequest): Promise<EmptyResponse> {
        const response = await this.optOutListingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Request suppression of a Duplicate.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Suppress
     */
    async suppressDuplicateRaw(requestParameters: SuppressDuplicateRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling suppressDuplicate.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling suppressDuplicate.');
        }

        if (requestParameters.duplicateId === null || requestParameters.duplicateId === undefined) {
            throw new runtime.RequiredError('duplicateId','Required parameter requestParameters.duplicateId was null or undefined when calling suppressDuplicate.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/duplicates/{duplicateId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"duplicateId"}}`, encodeURIComponent(String(requestParameters.duplicateId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Request suppression of a Duplicate.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Duplicates: Suppress
     */
    async suppressDuplicate(requestParameters: SuppressDuplicateRequest): Promise<EmptyResponse> {
        const response = await this.suppressDuplicateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Updates an Answer for a Question
     * Answer: Update
     */
    async updateAnswerRaw(requestParameters: UpdateAnswerRequest): Promise<runtime.ApiResponse<UpdateAnswerResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updateAnswer.');
        }

        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling updateAnswer.');
        }

        if (requestParameters.answerId === null || requestParameters.answerId === undefined) {
            throw new runtime.RequiredError('answerId','Required parameter requestParameters.answerId was null or undefined when calling updateAnswer.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updateAnswer.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/questions/{questionId}/answers/{answerId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))).replace(`{${"answerId"}}`, encodeURIComponent(String(requestParameters.answerId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnswerRequestToJSON(requestParameters.answerRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateAnswerResponseFromJSON(jsonValue));
    }

    /**
     * Updates an Answer for a Question
     * Answer: Update
     */
    async updateAnswer(requestParameters: UpdateAnswerRequest): Promise<UpdateAnswerResponse> {
        const response = await this.updateAnswerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Accept or reject a Publisher Suggestion.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Publisher Suggestions: Update
     */
    async updatePublisherSuggestionRaw(requestParameters: UpdatePublisherSuggestionRequest): Promise<runtime.ApiResponse<EmptyResponse>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling updatePublisherSuggestion.');
        }

        if (requestParameters.v === null || requestParameters.v === undefined) {
            throw new runtime.RequiredError('v','Required parameter requestParameters.v was null or undefined when calling updatePublisherSuggestion.');
        }

        if (requestParameters.suggestionId === null || requestParameters.suggestionId === undefined) {
            throw new runtime.RequiredError('suggestionId','Required parameter requestParameters.suggestionId was null or undefined when calling updatePublisherSuggestion.');
        }

        if (requestParameters.status === null || requestParameters.status === undefined) {
            throw new runtime.RequiredError('status','Required parameter requestParameters.status was null or undefined when calling updatePublisherSuggestion.');
        }

        const queryParameters: any = {};

        if (requestParameters.v !== undefined) {
            queryParameters['v'] = requestParameters.v;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["api-key"] = this.configuration.apiKey("api-key"); // api-key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
        }

        const response = await this.request({
            path: `/accounts/{accountId}/listings/publishersuggestions/{suggestionId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"suggestionId"}}`, encodeURIComponent(String(requestParameters.suggestionId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EmptyResponseFromJSON(jsonValue));
    }

    /**
     * Accept or reject a Publisher Suggestion.  **NOTE:** When sending requests to this endpoint, you must provide your Yext user ID in the **`Yext-User-Id`** header. 
     * Publisher Suggestions: Update
     */
    async updatePublisherSuggestion(requestParameters: UpdatePublisherSuggestionRequest): Promise<EmptyResponse> {
        const response = await this.updatePublisherSuggestionRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ListDuplicatesStatusesEnum {
    PossibleDuplicate = 'POSSIBLE_DUPLICATE',
    SuppressionRequested = 'SUPPRESSION_REQUESTED',
    Suppressed = 'SUPPRESSED',
    Unavailable = 'UNAVAILABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum ListEntityListingsStatusesEnum {
    NotSynced = 'NOT_SYNCED',
    SyncInProgress = 'SYNC_IN_PROGRESS',
    Live = 'LIVE',
    UpdateInProgress = 'UPDATE_IN_PROGRESS',
    CancelingSync = 'CANCELING_SYNC',
    NotApplicable = 'NOT_APPLICABLE',
    DeletePending = 'DELETE_PENDING',
    DeleteFailed = 'DELETE_FAILED',
    Deleted = 'DELETED',
    SyncStopped = 'SYNC_STOPPED'
}
/**
    * @export
    * @enum {string}
    */
export enum ListListingsStatusesEnum {
    WaitingOnYext = 'WAITING_ON_YEXT',
    WaitingOnCustomer = 'WAITING_ON_CUSTOMER',
    WaitingOnPublisher = 'WAITING_ON_PUBLISHER',
    Live = 'LIVE',
    Unavailable = 'UNAVAILABLE',
    OptedOut = 'OPTED_OUT'
}
/**
    * @export
    * @enum {string}
    */
export enum ListPublisherSuggestionsStatusesEnum {
    WaitingOnCustomer = 'WAITING_ON_CUSTOMER',
    Accepted = 'ACCEPTED',
    Rejected = 'REJECTED',
    Expired = 'EXPIRED'
}
/**
    * @export
    * @enum {string}
    */
export enum ListPublishersEntityTypeEnum {
    Location = 'LOCATION',
    HealthcareProfessional = 'HEALTHCARE_PROFESSIONAL',
    HealthcareFacility = 'HEALTHCARE_FACILITY',
    Restaurant = 'RESTAURANT',
    Atm = 'ATM',
    Event = 'EVENT'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdatePublisherSuggestionStatusEnum {
    Accepted = 'ACCEPTED',
    Rejected = 'REJECTED'
}
